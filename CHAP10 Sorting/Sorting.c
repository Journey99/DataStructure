/*
 < 정렬 - sorting >
 :물건을 크기 순으로 오름차순이나 내림차순을 나열하는 것
  자료 탐색에 있어서 필수적이다.

  # 정렬의 대상
	: 일반적으로 정렬시켜야 될 대상은 레코드(record)
		
  # 정렬 알고리즘 개요
	 : 모든 경우에 최적인 정렬 알고리즘은 없음

	 : 정렬 알고리즘의 평가 기준 -> 1) 비교횟수의 많고 적음
							        2) 이동 횟수의 많고 적음

	 - * 단순하지만 비효율적인 방법
		 -> 삽입정렬, 선택정렬, 버블정렬 등
	   * 복잡하지만 효율적인 방법
	     -> 퀵정렬, 히프정렬, 합병정렬, 기수정렬 등
   
     - * 내부 정렬 : 모든 데이터가 주기억장치에 저장되어진 상태에서 정렬 
	   * 외부 정렬 : 외부기억장치에 대부분의 데이터가 있고 일부만 주기억장치에 저장된 상태에서 정렬
	   
	- 정렬 알고리즘의 안정성
		: 동일한 키 값을 갖는 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음

 1) 선택 정렬 (selection sort)
	: 정렬된 왼쪽 리스트와 정렬안된 오른쪽 리스트 가정

	- 복잡도 분석
		*비교 횟수 : O(n^2)
		*이동 횟수 : 3(n-1)
		*전체 시간적 복잡도 : O(n^2)
		* 안전성을 만족하지 않음
	
2) 삽입 정렬 (insertion sort)
	
	- 복잡도 분석
		* 최선의 경우 : O(n)
		* 최악의 경우 : O(n^2)
		* 평균의 경우 : O(n^2)
		* 많은 이동 필요 -> 레코드가 클 경우 불리
		
3) 버블 정렬 (bubble sort)
	: 인접한 2개의 레코드를 비교하여 순서대로 되어 있지 않으면 서로 교환

	- 복잡도 분석
		* 비교 횟수(최상, 평균, 최악) : O(n^2)
		* 이동 횟수 : O(n^2)
		* 레코드 이동 과다!
		
4) 셸 정렬 (shell sort)
	: 삽입 정렬이 어느 정도 정렬된 리스트에서 대단히 빠른 것에 착안
	  삽입 정렬은 요소들이 이웃한 위치로만 이동하므로, 많은 이동에 의해서만 요소가 제자리를 찾아감
	  요소들이 멀리 떨어진 위치로 이동할 수 있게 하면, 보다 적게 이동하여 제자리 찾을 수 있음
	  => 전체 리스트를 일정 간격(gap)의 부분 리스트로 나눔

	 - 복잡도 분석
		* 최악 : O(n^2)
		* 평균 : O(n^1.5)
		* 장점 : 불연속적인 부분 리스트에서 원거리 자료 이동으로 보다 적은 위치 교환으로 제자리 찾을  가능성 증대
				 부분 리스트가 점진적으로 정렬된 상태가 되므로 삽입정렬 속도 증가

5) 합병 정렬( merge sort)
	: 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분리스트를 정렬
	  정렬된 두 개의 부분 리스트를 합하여 전체 리스트를 정렬함

	  - 분할 정복
		1. 분할 : 배열을 같은 크기의 2개의 부분 배열로 분할
		2. 정복 : 부분배열을 정렬한다. 부분배열의 크기가 충분히 작지 않으면 재귀호출을 이용하여 다시 분할정복기법 적용
		3. 결합 : 정렬된 부분배열을 하나의 배열에 통합
	 
	 - 복잡도 분석
		* 비교 횟수 : 크기 n인 리스트를 정확히 균등 분배하므로 log(n)개의 패스
		              각 패스에서 리스트의 모든 레코드 n개를 비교하므로 n번의 비교 연산
		* 이동 횟수 : 레코드의 이동이 각 패스에서 2n번 발생하므로 전체 레코드의 이동은 2n*log(n)번 발생
		* 최적, 평균, 최악의 경우 큰 차이 없이 O(n*log(n))
		* 안정적이며 데이터의 초기 분산 순서에 영향을 덜 받음

6) 퀵 정렬(quick sort)
	: 평균적으로 가장 빠른 정렬 방법
	  분할정복법 사용
	  리스트를 2개의 부분리스트로 비균등 분할하고, 각각의 부분리스트를 다시 퀵정렬함
	
	- 복잡도 분석
		* 최선의 경우 : 패스의 수 log(n)
		                각 패스 안에서 비교횟수 n
						총 비교횟수 n*log(n)
		* 최악의 경우 : 패스의 수 n
					    각 패스 안에서 비교횟수 n
						총 비교횟수 n^2
			-> 중간값을 피벗으로 선택하면 불균등 분할 완화 가능

7) 기수 정렬(radix sort)
	: 레코드를 비교하지 않고 정렬 수행
	  기수 정렬은 O(dn)의 시간적복잡도를 가짐 (d=자리수)
	  단순히 자리수에 따라 버켓에 넣었다가 꺼내면 정렬됨
	  낮은 자리수로 먼저 분류한 다음, 순서대로 읽어서 다시 높은 자리수로 분류
	  버켓은 큐로 구현
	
	- 복잡도 분석
		* O(dn)의 시간적 복잡도
		* 실수, 한글, 한자로 이루어진 키는 정렬 못함
	
	
*/